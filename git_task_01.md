## **Первоначальная настройка Git** ##

В состав Git входит утилита *git config*, которая позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git, а также его внешний вид. 


**1. Имя пользователя**

Первое, что вам следует сделать после установки Git — указать ваше имя и адрес электронной почты.  
> git config --global user.name "John Doe">

> git config --global user.email johndoe@example.com >


**2. Настройка ветки по умолчанию**  

Когда вы инициализируете репозиторий командой *git init*, Git создаёт ветку с именем ***master*** по умолчанию. Например, чтобы установить имя ***main*** для вашей ветки по умолчанию, выполните следующую команду:
> git config --global init.defaultBranch main>

## **Создание Git-репозитория** ##

Обычно вы получаете репозиторий Git одним из двух способов:
1. Вы можете взять локальный каталог, который в настоящее время не находится под версионным контролем, и превратить его в репозиторий Git, либо

2. Вы можете клонировать существующий репозиторий Git из любого места.

В обоих случаях вы получите готовый к работе Git репозиторий на вашем компьютере.

**Создание репозитория в существующем каталоге**

Если у вас уже есть проект в каталоге, который не находится под версионным контролем Git, то для начала нужно перейти в него. Для Windows:
> cd C:/Users/user/my_project

а затем выполните команду:

> git init

Эта команда создаёт в текущем каталоге новый подкаталог с именем *.git*, содержащий все необходимые файлы репозитория — структуру Git репозитория. На этом этапе ваш проект ещё не находится под версионным контролем.

## **Запись изменений в репозиторий** ##

Каждый файл в рабочем каталоге может находиться в одном из двух состояний: под версионным контролем **(отслеживаемые)** и нет **(неотслеживаемые)**.   

1.  **Отслеживаемые** файлы — это те файлы, о которых знает Git.

2. **Неотслеживаемые** файлы — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту.

Как только файлы отредактированны, Git будет рассматривать их как изменённые. Необходимо индексировать эти изменения, затем зафиксировать все проиндексированные изменения, после чего цикл повторяется.

![рисунок 1 Жизненный цикл состояний файлов](https://git-scm.com/book/en/v2/images/lifecycle.png "Рис. 1 Жизненный цикл состояний файлов") 

**1. Определение состояния файлов**

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда *git status*. 

>git status

**2. Отслеживание новых файлов**

Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда *git add*. Чтобы начать отслеживание файла **README**, вы можете выполнить следующее:

>git add README 

*git add* - это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния.

**3. Коммит изменений**

Теперь, когда ваш индекс находится в нужном состоянии,можно зафиксировать изменения. Запомните, всё, что до сих пор не проиндексировано — любые файлы, созданные или изменённые вами, и для которых вы не выполнили *git add* после редактирования — не войдут в этот коммит. Они останутся изменёнными файлами на вашем диске. В нашем случае, когда вы в последний раз выполняли *git status*, вы видели что всё проиндексировано, и вот, вы готовы к коммиту. Простейший способ зафиксировать изменения — это набрать *git commit*:

> git commit -m "комментарий"

***Итак, вы создали свой первый коммит!*** Вы можете видеть, что коммит вывел вам немного информации о себе: на какую ветку вы выполнили коммит (**master**), какая контрольная сумма SHA-1 у этого коммита (463dc4f), сколько файлов было изменено, а также статистику по добавленным/удалённым строкам в этом коммите.

Запомните, всё, что вы не проиндексировали, так и висит в рабочем каталоге как изменённое; вы можете сделать ещё один коммит, чтобы добавить эти изменения в репозиторий. Каждый раз, когда вы делаете коммит, вы сохраняете снимок состояния вашего проекта, который позже вы можете восстановить или с которым можно сравнить текущее состояние.

**4. Просмотр истории коммитов**

После того, как вы создали несколько коммитов, вероятно вам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда *git log*.

## **Создание новой ветки** ##

## **Управление ветками** ##

Команда *git branch* делает несколько больше, чем просто создаёт и удаляет ветки. При запуске без параметров, вы получите простой список имеющихся у вас веток:

> git branch
>  iss53

>*master
> testing

Обратите внимание на символ *, стоящий перед веткой **master**: он указывает на ветку, на которой вы находитесь в настоящий момент (т. е. ветку, на которую указывает **HEAD**). Это означает, что если вы сейчас сделаете коммит, ветка **master** переместится вперёд в соответствии с вашими последними изменениями. Чтобы посмотреть последний коммит на каждой из веток, выполните команду *git branch -v*:

> git branch -v
>  iss53   93b412c Fix javascript issue
> 
>*master  7a98805 Merge branch 'iss53'

>testing 782fd34 Add scott to the author list in the readme

Опции *--mergedи -no-merged* могут отфильтровать этот список для вывода только тех веток, которые слиты или ещё не слиты в текущую ветку. Чтобы посмотреть те ветки, которые вы уже слили с текущей, можете выполнить команду *git branch --merged*:

> git branch --merged
>  iss53
>
> *master

Чтобы увидеть все ветки, содержащие наработки, которые вы пока ещё не слили в текущую ветку, выполните команду *git branch --no-merged*:

> git branch --no-merged
> 
> testing

Вы увидите оставшуюся ветку. Так как она содержит ещё не слитые наработки, попытка удалить её командой *git branch -d* приведёт к ошибке:

>git branch -d testing

>error: The branch 'testing' is not fully merged.

>If you are sure you want to delete it, run 'git branch -D testing'.

Если вы действительно хотите удалить ветку вместе со всеми наработками, используйте опцию *-D*

## **Основы ветвления и слияния** ##

**Основы ветвления**

Чтобы создать ветку и сразу переключиться на нее, можно выполнить команду *git checkout* с параметром *-b*:

> git checkout -b iss53

> Switched to a new branch "iss53"

Это то же самое что и:

> git branch iss53

> git checkout iss53

Вы работаете над своим сайтом и делаете коммиты. Это приводит к тому, что ветка *iss53* движется вперед, так как вы переключились на нее ранее (**HEAD** указывает на нее).

> vim index.html

> git commit -a -m 'Create new footer [issue 53]'

Но перед тем как переключиться — имейте в виду, что **если рабочий каталог либо индекс содержат незафиксированные изменения, конфликтующие с веткой, на которую вы хотите переключиться, то Git не позволит переключить ветки.** Лучше всего переключаться из чистого рабочего состояния проекта. Вы зафиксировали все свои изменения и можете переключиться на ветку **master**:

>git checkout master

>Switched to branch **'master'**

Теперь вы можете перейти к написанию исправления. Cоздайте новую ветку для исправления, в которой будуту работать, пока не законили исправление.

> **git checkout -b hotfix**

> Switched to a new branch 'hotfix'

>vim index.html

>**git commit -a -m 'Fix broken email address'**

>[hotfix 1fb7853] Fix broken email address

>1 file changed, 2 insertions(+)

Слияние веток делается командой *git merge*:

> git checkout master

> git merge hotfix

Если коммит сливается с тем, до которого можно добраться двигаясь по истории прямо, Git упрощает слияние просто перенося указатель ветки вперед, так как нет расхождений в изменениях.

Для удаления ветки выполните команду *git branch* с параметром *-d*:

> **git branch -d hotfix**

> Deleted branch hotfix (3a0874c).


Cоздаётся новый указатель для дальнейшего перемещения. 
Вы хотите создать новую ветку с именем testing. 
Вы можете это сделать командой **git branch**

> git branch testing

В результате создаётся новый указатель на текущий коммит.

Как Git определяет, в какой ветке вы находитесь? 
Он хранит специальный указатель **HEAD**.  
В Git — это указатель на текущую локальную ветку. В нашем случае мы все еще находимся в ветке **master**. Команда *git branch* только создаёт новую ветку, но не переключает на неё.  Вы можете легко это увидеть при помощи простой команды *git log*, которая покажет вам куда направляют указатели веток. Эта опция называется *--decorate*.

> git log --oneline --decorate

>f30ab (HEAD -> master, testing)
> Add feature #32 - ability to add new formats to the central interface
34ac2 Fix bug #1328 - stack overflow under certain conditions
98ca9 Initial commit>

Здесь можно увидеть указывающие на коммит f30ab ветки: **master** и **testing**.

## **Переключение веток** ##

Для переключения на существующую ветку выполните команду *git checkout*. 
Давайте переключимся на ветку **testing**:

> git checkout testing

В результате указатель **HEAD** переместится на ветку **testing**.

Какой в этом смысл? Давайте сделаем ещё один коммит:

> git commit -a -m 'made a change'

Интересная ситуация: указатель на ветку **testing** переместился вперёд, а **master** указывает на тот же коммит, где вы были до переключения веток командой *git checkout*. 
Давайте переключимся назад на ветку **master**:

> git checkout master 

Эта команда сделала две вещи: переместила указатель **HEAD** назад на ветку **master** и вернула файлы в рабочем каталоге в то состояние, на снимок которого указывает *master**. Это также означает, что все вносимые с этого момента изменения будут относиться к старой версии проекта. Другими словами, вы откатили все изменения ветки **testing** и можете продолжать в другом направлении.

**ВАЖНО**

 ***git log* не показывает все ветки по умолчанию
Если выполнить команду *git log* прямо сейчас, то в её выводе только что созданная ветка «testing» фигурировать не будет.**

Ветка никуда не исчезла; просто Git не знает, что именно она вас интересует, и выводит наиболее полезную по его мнению информацию. Другими словами, по умолчанию *git log* отобразит историю коммитов только для текущей ветки. 

**Переключение веток меняет файлы в рабочем каталоге**
Важно запомнить, что при переключении веток в Git происходит изменение файлов в рабочем каталоге. Если вы переключаетесь на старую ветку, то рабочий каталог будет выглядеть так же, как выглядел на момент последнего коммита в ту ветку. **Если Git по каким-то причинам не может этого сделать — он не позволит вам переключиться вообще.**

Вы создали ветку и переключились на нее, поработали, а затем вернулись в основную ветку и поработали в ней. Эти изменения изолированы друг от друга: вы можете свободно переключаться туда и обратно, а когда понадобится — объединить их. И все это делается простыми командами: *branch*, *checkout* и *commit*.

Все описанные действия можно визуализировать с помощью команды *git log*. 
Для отображения истории коммитов, текущего положения указателей веток и истории ветвления выполните команду *git log --oneline --decorate --graph --all*.

**Одновременное создание новой ветки и переключение на неё**

Как правило, при создании новой ветки вы хотите сразу на неё переключиться — это можно сделать используя команду *git checkout -b "newbranchname"*.

Начиная с Git версии 2.23, вы можете использовать *git switch* вместо *git checkout*, чтобы:

Переключиться на существующую ветку: 

>git switch testing-branch.

Создать новую ветку и переключиться на нее: 

>git switch -c new-branch. 

Флаг -c* означает создание, но также можно использовать полный формат:*` --create`*.

Вернуться к предыдущей извлечённой ветке:
> git switch -.

Для просмотра истории коммитов другой ветки необходимо явно указать её имя: git log testing Чтобы посмотреть историю по всем веткам — выполните команду с дополнительным флагом: git log --all.



[За основу взят материал с сайта Git-scm.com](https://git-scm.com/book/ru)

Для оформления использовала "Краткое руководство по Маркдауну"

[Краткое руководство по Маркдауну] https://paulradzkov.com/2014/markdown_cheatsheet/




















